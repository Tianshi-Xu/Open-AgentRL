# Copyright 2024 Bytedance Ltd. and/or its affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import ast
import asyncio
import json
import logging
import os
from abc import ABC, abstractmethod
from typing import Any

import regex as re
from pydantic import BaseModel

from verl.utils.rollout_trace import rollout_trace_op

logger = logging.getLogger(__file__)
logger.setLevel(os.getenv("VERL_LOGGING_LEVEL", "INFO"))


class FunctionCall(BaseModel):
    arguments: str
    """
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """

    name: str
    """The name of the function to call."""


class ToolParser(ABC):
    _registry: dict[str, type["ToolParser"]] = {}

    def __init__(self, tokenizer, **_: Any) -> None:
        self.tokenizer = tokenizer

    @abstractmethod
    async def extract_tool_calls(self, responses_ids: list[int]) -> tuple[str, list[FunctionCall], list[str]]:
        """Extract tool calls from the responses.

        Args:
            responses_ids (List[int]): The ids of the responses.

        Returns:
            Tuple[str, List[FunctionCall], List[str]]: Remaining content, extracted tool calls, and parser errors.
        """
        raise NotImplementedError

    @classmethod
    def get_tool_parser(cls, name: str, tokenizer, **kwargs: Any):
        if name not in cls._registry:
            raise ValueError(f"Unknown tool parser: {name}")
        return cls._registry[name](tokenizer, **kwargs)

    @classmethod
    def register(cls, name: str):
        def decorator(subclass: type[ToolParser]) -> type[ToolParser]:
            cls._registry[name] = subclass
            return subclass

        return decorator


@ToolParser.register("hermes")
class HermesToolParser(ToolParser):
    """Adapted from https://github.com/vllm-project/vllm/blob/v0.9.1/vllm/entrypoints/openai/tool_parsers/hermes_tool_parser.py"""

    def __init__(self, tokenizer, enable_repair: bool | None = None) -> None:
        super().__init__(tokenizer)

        env_value = os.getenv("VERL_TOOL_PARSER_ENABLE_REPAIR")
        if enable_repair is None:
            if env_value is None:
                enable_repair = True
            else:
                enable_repair = env_value.lower() not in {"0", "false", "no"}
        elif isinstance(enable_repair, str):
            enable_repair = enable_repair.lower() not in {"0", "false", "no"}
        elif not isinstance(enable_repair, bool):
            raise TypeError(
                f"enable_repair must be a bool, string, or None; got {type(enable_repair).__name__}"
            )
        # print("enable_repair =", enable_repair)    
        self.enable_repair = enable_repair

        self.tool_call_start_token: str = "<tool_call>"
        self.tool_call_end_token: str = "</tool_call>"
        self.tool_call_regex = re.compile(r"<tool_call>(.*?)</tool_call>", re.DOTALL)
        self._invalid_escape_regex = re.compile(r"\\([^\"\\/bfnrtu])")
        self._control_char_regex = re.compile(r"[\x00-\x08\x0b\x0c\x0e-\x1f]")
        self._json_keyword_patterns: list[tuple[re.Pattern[str], str]] = [
            (re.compile(r"(?<![\\w\"\'])\btrue\b", re.IGNORECASE), "True"),
            (re.compile(r"(?<![\\w\"\'])\bfalse\b", re.IGNORECASE), "False"),
            (re.compile(r"(?<![\\w\"\'])\bnull\b", re.IGNORECASE), "None"),
        ]

    @rollout_trace_op
    async def extract_tool_calls(self, responses_ids: list[int]) -> tuple[str, list[FunctionCall], list[str]]:
        loop = asyncio.get_running_loop()
        text = await loop.run_in_executor(None, self.tokenizer.decode, responses_ids)
        if self.tool_call_start_token not in text or self.tool_call_end_token not in text:
            return text, [], []

        matches = self.tool_call_regex.findall(text)
        function_calls: list[FunctionCall] = []
        parse_errors: list[str] = []
        for match in matches:
            function_call = self._parse_tool_call(match)
            if function_call is None:
                truncated = match.strip()[:200]
                parse_errors.append(f"Tool call parsing failed: unable to decode payload: {truncated}")
                continue

            if isinstance(function_call, str):
                parse_errors.append(function_call)
                continue

            if not isinstance(function_call, dict):
                err_msg = f"Tool call payload is not a JSON object: {str(function_call)[:200]}"
                logger.error(err_msg)
                parse_errors.append(err_msg)
                continue

            name = function_call.get("name")
            arguments = function_call.get("arguments", {})
            if not isinstance(name, str) or not name.strip():
                err_msg = "Failed to decode tool call: missing or invalid function name"
                logger.error(err_msg)
                parse_errors.append(err_msg)
                continue

            if isinstance(arguments, str):
                arguments_payload = arguments
            else:
                try:
                    arguments_payload = json.dumps(arguments, ensure_ascii=False)
                except (TypeError, ValueError) as e:
                    err_msg = f"Failed to decode tool call arguments for {name}: {e}"
                    logger.error(err_msg)
                    parse_errors.append(err_msg)
                    continue

            function_calls.append(FunctionCall(name=name, arguments=arguments_payload))

        # remaing text exclude tool call tokens
        content = self.tool_call_regex.sub("", text)

        return content, function_calls, parse_errors

    def _parse_tool_call(self, match: str) -> dict[str, Any] | str | None:
        raw_payload = match.strip()
        if not raw_payload:
            return None
        # logger.info("enable_repair=%s", self.enable_repair)
        # First try direct JSON parsing
        try:
            return json.loads(raw_payload)
        except json.JSONDecodeError:
            pass
        
        if not self.enable_repair:
            err_msg = f"Tool call parsing failed in strict mode: {raw_payload[:200]}"
            logger.error(err_msg)
            return err_msg

        repaired_payload = self._repair_payload(raw_payload)
        try:
            return json.loads(repaired_payload)
        except json.JSONDecodeError as json_err:
            # Fall back to Python literal parsing for lenient inputs
            literal_ready_payload = repaired_payload
            for pattern, replacement in self._json_keyword_patterns:
                literal_ready_payload = pattern.sub(replacement, literal_ready_payload)
            try:
                literal_candidate = ast.literal_eval(literal_ready_payload)
                if isinstance(literal_candidate, dict):
                    return literal_candidate
            except Exception:
                err_msg = (
                    f"Failed to decode tool call after repair: {json_err} | {raw_payload[:200]}"
                )
                logger.error(err_msg)
                return err_msg
        return None

    def _repair_payload(self, payload: str) -> str:
        repaired = payload
        # Escape control characters that break JSON parsing
        repaired = self._control_char_regex.sub(lambda m: f"\\u{ord(m.group(0)):04x}", repaired)
        # Escape unknown backslash sequences to keep them literal
        repaired = self._invalid_escape_regex.sub(lambda m: "\\\\" + m.group(1), repaired)
        # Remove trailing commas before closing braces/brackets while respecting quoted regions
        repaired = self._strip_trailing_commas(repaired)
        return repaired

    def _strip_trailing_commas(self, payload: str) -> str:
        result: list[str] = []
        in_string = False
        string_delim = ""
        i = 0
        length = len(payload)
        while i < length:
            ch = payload[i]
            if ch in {'"', "'"}:
                if not in_string:
                    in_string = True
                    string_delim = ch
                elif not self._is_escaped(payload, i) and ch == string_delim:
                    in_string = False
                    string_delim = ""
                result.append(ch)
                i += 1
                continue
            if ch == '\\' and in_string:
                # Preserve escape sequences inside strings
                result.append(ch)
                if i + 1 < length:
                    result.append(payload[i + 1])
                    i += 2
                else:
                    i += 1
                continue
            if ch == ',' and not in_string:
                j = i + 1
                while j < length and payload[j].isspace():
                    j += 1
                if j < length and payload[j] in '}]':
                    i += 1
                    continue
            result.append(ch)
            i += 1
        return ''.join(result)

    @staticmethod
    def _is_escaped(text: str, index: int) -> bool:
        backslash_count = 0
        idx = index - 1
        while idx >= 0 and text[idx] == '\\':
            backslash_count += 1
            idx -= 1
        return (backslash_count % 2) == 1
